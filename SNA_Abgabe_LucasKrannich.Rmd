---
title: "SNA_Abgabe_LucasKrannich"
author: "Lucas Krannich"
date: "2025-06-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Social Network Analysis - Wikispeedia - Lucas Krannich

Das vorliegende Projekt wurde in einzelarbeit statt in Gruppenarbeit durchgeführt.Im folgenden findet eine Netzwerkanalyse des Datensatzes "Wikispeedia Navigation Paths" statt.
Der Datensatz enthält aufgezeichnete Navigationspfade des Browserspiels "Wikispeedia". In Wikispeedia werden die Benutzer aufgefordert, von einer bestimmten Quelle zu einem bestimmten Zielartikel zu navigieren, indem sie nur Wikipedia-Links anklicken.

Auf den zugrundliegenden Datensatz kann über die Stanford Large Network Dataset collection (SNAP) zugegriffen werden. https://snap.stanford.edu/data/wikispeedia.html


Das vorliegende Projekt orientiert sich Grundlegend an dem folgenden Artikel:
https://studentwork.prattsi.org/infovis/labs/exploring-the-network-behind-wikispeedia/

Die Starke orientierung an dem verlinkten Artikel ist unter anderem damit zu begründen, dass der Autor eher zu den "fachlich schwächeren Studenten" gehört, mit diesem Projekt allerdings eine Herausforderung gesucht wurde, um sich selbst weiter zu entwickeln.

Im zugrundeliegenden Artikel werden neben RStudio auch die Tools "Open Refine" und "Gephi" genutzt. In der vorliegenden Arbeit wird von der Nutzung von Gephi abgesehen und es wird lediglich Open Refine genutzt.

Open Refine ist ein Tool zur Datenbereinigung und -aufbereitung. Es unterstützt den benutzer hierbei mit einer grafischen Oberfläche. Im folgenden wird im Kapitel Data Cleaning erneut darauf eingegangen.


## Imports (Data & Libraries)


```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
```

TSV-Datei einlesen & Info zu Daten ausgeben

```{r read df, message=FALSE, warning=FALSE}
df <- read_tsv("C:/Users/Krann/GitHub/SNA/Wikispeedia-paths-finished.tsv", col_names = TRUE)
```

```{r df head}
head(df)
```



## Data Cleaning

Die Daten wurden vor dem Einlesen in R bereits mit Open Refine bereinigt. Die Bereinigung in Open Refine basiert auf der beschreibung des Artikels. Die bereinigte Version der Daten ist im verlinkten GitHub zu finden. https://github.com/krannichl/SNA/tree/main
IN der Bereinigung wurden Zeilen, deren Navigationspfade die ein "<" Zeichen enthalten entfernt. Ein "<" Zeichen lässt darauf schließen, dass der Spieler auf die vorherige Wikipediaseite zurück gesprungen ist. In der vorliegenden Analyse sollen nur Pfade betrachtet werden, die direkt von Start- zu Endpunkt durchgeführt wurden, ohne zurück zu gehen. Es soll ein ungerichtetes Netzwerkt dargestellt werden.
Zudem wurden alle Zeilen entfernt, in denen der Spieler maximal 2min gebraucht hat. So können ausreiser vermieden werden und die verbleibenden Datenbasis ist homogen in dieser Eigenschaft.

Trotz vorheriger Bereinigung enthält der Datensatz noch "NULL" werte. Diese sind in der Spalte "Rating" wiederzufinden. Allerdings hadelt es sich hierbei nicht um klassische 0 werte, sondern um String werte. Im nächsten Schritt werden alle Zeilen, die einen Null-Wert enthalten, entfernt.
Die Null-Werte werden in R-Entfernt. In Open Refine wäre dies auch möglich gewesen, es wurde sich aber dagegen entschieden, da der Umgang & Die Arbeit mit Open Refine teilweise nicht so intuitiv ist und eine Bereinigung in R schneller geht. Auf eine erneute verwendung von Open Refine würde in zukünftigen Projekten nur zurückgegriffen werden, wenn zuvor bereits alle bereinigungsschritte klar sind, da die verwendung von Open Refine sonst eher umständlich ist.

```{r df filter, message=FALSE }
df <- df %>%
  filter(rating != "NULL")

nrow(df)
```


Der Datensatz wurde von ca. 50.000 Zeilen auf 13.527 Zeilen herunter reduziert.


```{r df head2}
head(df)
```

Alle Null Werte wurden entfernt.
Der Datensatz ist jetzt vollständig bereinigt.

## Vorbereitung Netzwerk Analyse

Im ersten Schritt wird die Funktion Extract Edges erstellt.
Die Navigationspfade aus dem Datensatz werden ausgelesen aufgeteilt und gespeichert. Pfade mit weniger als 2 Werten werden ignoriert. Das liegt daran, dass der Startpunkt somit auch dem Endpunkt wäre.
Anschließend wird eine gerichtete Edgelist erstellt.

```{r edgelist function}

extract_edges <- function(path_string) {
  pages <- unlist(strsplit(path_string, ";"))
  if (length(pages) < 2) return(NULL)
  edges <- data.frame(
    source = pages[-length(pages)],
    target = pages[-1]
  )
  return(edges)
}

```

Die Funktion extract_edges wird auf den Datensatz angewandt.
Die Variable edge_list enthält nun die gerichtete Edge List für alle Navigationspfade des Datensatzes.

```{r create edge list}
edge_list <- df %>%
  pull(path) %>%
  map_dfr(extract_edges)
```

Die Edge List wird entsprechend der Häufigkeit der einzelnen Pfaden Aggregiert und in der Variable weighted_edges gespeichert. 

```{r edge list gewichten}
weighted_edges <- edge_list %>%
  count(source, target, name = "weight")
```

Da das Ziel der Analyse die Erstellung eines ungerichteten Graphen ist, wird die "gerichtetheit" der Edge List aufgehoben.

```{r gerichtetheit aufheben}
g <- graph_from_data_frame(weighted_edges, directed = FALSE)
```

Berechnung von 2 Zentralitätsmaße für alle Knoten im Netzwerk.

Betweenness: Wie oft liegt ein Knoten auf den kürzesten Pfaden zwischen anderen Knoten.
-> Es wrde sich für die Betweenness entschieden, da erkannt werden sollte, welche Knoten eine "Verbinder Rolle" haben (hierfür spricht ein hoher wert)

Degree: Berechnet für jeden Knoten die Anzahl der angrenzenden Kanten.
-> Ein hoher Wert spricht dafür, dass der Knoten eine hohe lokale Konnektivität hat. Da er sich eignet, um populäre Seiten / populären Knoten zu identifizieren, wurde dieser Wert gewählt.

```{r Zentralitätsmaße}
V(g)$betweenness <- betweenness(g)
V(g)$degree <- degree(g)
```

## "Naiver Plot"

Im folgenden wird zunächst der erste Plot des Netzwerks dargelegt, um den Stand nach der Datenbereinigung zu visualisieren.

```{r Naiver PLot}
plot_unfiltered_network <- ggraph(g, layout = "fr") +
  # Kanten: Gewicht → Breite, Farbe: dezent
  geom_edge_link(aes(width = weight), alpha = 0.2, color = "gray40") +
  scale_edge_width(range = c(0.2, 3)) +

  # Knoten: Größe nach Betweenness, Farbe nach Degree
  geom_node_point(aes(size = betweenness, color = degree), show.legend = TRUE) +
  scale_size_continuous(range = c(1, 10)) +
  scale_color_viridis_c(option = "B", direction = -1) +

  # Knotenbeschriftung – stark eingeschränkt zur Vermeidung von Überladung
  geom_node_text(aes(label = name), repel = TRUE, size = 2.5, max.overlaps = 10) +

  theme_void() +
  labs(
    title = "Wikispeedia Netzwerkvisualisierung (ungesäubert)",
    subtitle = "Größe = Betweenness Centrality | Farbe = Degree | Keine Filterung"
  ) +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 12)
  )

```

```{r print Naive plot }
print(plot_unfiltered_network)
```

Da es sich nach dem Data Cleaning immernoch um ein sehr umfangreiches Netzwerk handelt, wird es auf den Degree gefiltert und Knoten deren Degree unter dem festgelegten Schwellenwert "60" liegen, werden in der Weiteren Analyse nicht weiter beachtet.
Dieses Vorgehen schafft einerseits ein übersichtlicheres Netzwerk unterstützt, da das Rauschen im Datensatz veringert wird. Andererseits wird der Fokus der Analyse stärker auf die Kernstruktur gelegt, da lediglich strukturell relevante Knoten in die Analyse mit einbezogen werden. Zudem wird eine übersichtlichere Visuelle Darstellung ermöglicht.

Eine Alternative Filterung auf die Betweenness wurde in der vorliegenden Analysennicht durchgeführt.

```{r degree filter}
min_degree_threshold <- 60


g_filtered <- g %>%
  delete_vertices(V(g)$degree < min_degree_threshold) # Knoten mit weniger als X Verbindungen entfernen


cat("Anzahl der Knoten im ursprünglichen Graphen:", vcount(g), "\n")
cat("Anzahl der Knoten im gefilterten Graphen (Degree-Filter):", vcount(g_filtered), "\n")
```


Erneute berechnung der Betweenness- und Degree-Werte,auf Basis des gefilterten Netzwerks.
Dies ist notwendig, weil sich durch das Entfernen von Knoten im vorherigen Schritt auch die Struktur des Netzwerks verändert und damit die relativen zentralen Rollen der verbliebenen Knoten neu zu bestimmen sind.


```{r Zentralitätsmaße2}
V(g_filtered)$betweenness <- betweenness(g_filtered)
V(g_filtered)$degree <- degree(g_filtered)

```

# Visualisierung des gefilterten Netzwerks

```{r gefilterter Plot, warning=FALSE}
plot_filtered_network <- ggraph(g_filtered, layout = "fr") +
  # Kanten: Breite nach Gewicht, Farbe dunkelgrün
  geom_edge_link(aes(width = weight), alpha = 0.3, color = "darkgreen") + # alpha leicht erhöht
  scale_edge_width(range = c(0.5, 5)) + # Bereich für Kantenbreite angepasst für bessere Sichtbarkeit
  
  # Knoten: Größe nach Betweenness, Farbe nach Degree
  geom_node_point(aes(size = betweenness, color = degree), show.legend = TRUE) +
  scale_size_continuous(range = c(3, 15)) + # Bereich für Knotengröße angepasst für bessere Sichtbarkeit
  scale_color_viridis_c(option = "B", direction = -1) + # Eine bessere Farbskala (viridis)
  geom_node_text(aes(label = name), repel = TRUE, size = 3, max.overlaps = 20) + # Knotenbeschriftungen
  
  theme_void() + # Entfernt Achsen und Hintergrund
  labs(
    title = "Wikispeedia Netzwerkvisualisierung (gefiltert)",
    subtitle = "Größe = Betweenness Centrality | Farbe = Degree | Filter: Degree > 60"
  ) +
  theme(
    legend.position = "right", # Legendenposition anpassen
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    plot.subtitle = element_text(hjust = 0.5, size = 12)
  )
```

```{r print gefilterter Plot}
print(plot_filtered_network)
```

Das gefilterte Netzwerk ist bereits besser Interpretierbar. 
Sowohl die Betweenness als auch der Degree der Knoten ist ersichtlich und bietet einen klaren Einblick in die Relevanz der knoten.
Jedoch ist hervorzuheben, dass die gewichtung der Kanten in der Gewählten Darstellung optimierungspotenzial hat, da diese in der visuellen Darstellung kaum erkenntlich ist.
Zudem liegt im vorliegenden Fall die Problematik vor, dass mit einem gewinn an übersichtlichkeit die gefahr besteht informationen zu verlieren.
Um die visuellen erkenntnisse zu unterstützen werden im folgenden die knoten gemäß ihrer Betweenness, Degree und Gewichtungswerte tabellarisch dargestellt.

## tabellarische Darstellung

Aufgrund des Umfangs der Daten werden im vorliegenden Markdown nur die Vorschau auf die Tabellen (Tabellenköpfe) dargestellt.

```{r df für Netzwerk Tabellenansicht}
node_metrics_df <- as_data_frame(g_filtered, what = "vertices")
```

```{r Netzwerk Tabellenansicht sortiert nach betweeness}
node_metrics_df_sorted_betweenness <- node_metrics_df %>%
  arrange(desc(betweenness))

head(node_metrics_df_sorted_betweenness, n= 10)


tail(node_metrics_df_sorted_betweenness, n= 10)
```
Betweenness zeigt die relative Bedeutung eines knotens im Netzwerk
Größte Rolle z.B. über die Kommunikation zwischen anderen Menschen in einem sozialen Netzwerk
Wie wichtig ist ein Knoten in seinem Netzwerk

.......................................................................

Betweenness misst, wie häufig ein Knoten (Wikipedia-Seite) auf den kürzesten Pfaden zwischen anderen Knoten liegt.

Ein hoher Betweenness-Wert bedeutet: Die Seite fungiert als Vermittler oder "Brücke" im Netzwerk.

Sie ist also für die Navigation oft ein Zwischenschritt, über den viele Wege führen.

Eine Wikipedia-Seite mit hoher Betweenness war im Spiel oft ein Zwischenschritt zwischen Start- und Zielseite.

Sie ist möglicherweise thematisch breit verbunden und dient als Knotenpunkt für viele unterschiedliche Themenbereiche.




```{r Netzwerk Tabellenansicht sortiert nach degree}
node_metrics_df_sorted_degree <- node_metrics_df %>%
  arrange(desc(degree))

head(node_metrics_df_sorted_degree, n= 10)

tail(node_metrics_df_sorted_degree, n= 10)
```
degree zeigt die Kontakthäufigkeit oder die anzahl der Beziehungen zu anderen Knoten

...................................................................

Der Degree misst, wie viele direkte Verbindungen ein Knoten hat – also wie viele andere Seiten über Kanten mit ihm verbunden sind.

Hier: Wie oft wurde eine Seite als Quelle oder Ziel in einer Kante verwendet (da du später ein ungerichtetes Netzwerk benutzt, zählt beides gleich).

In deinem Kontext:
Seiten mit hohem Degree sind oft direkt besucht oder von vielen anderen Seiten aus erreicht worden.

Sie sind beliebte Knoten im Navigationsverhalten – entweder, weil sie besonders zentral oder relevant sind.

```{r Netzwerk Tabellenansicht sortiert nach Gewicht}
edge_df <- as_data_frame(g_filtered, what = "edges")

edge_df_sorted <- edge_df %>%
  arrange(desc(weight))

head(edge_df_sorted,n= 10)

tail(edge_df_sorted, n= 10)

```
Die Häufigkeit, mit der eine bestimmte Wikipedia Seite (also der Übergang von einer Wikipedia-Seite zur nächsten) in den Navigationspfaden der Nutzer vorkommt

# Auf Basis der Tabelenwerte erste sachen erklären




## Hier Fazit und sagen, dass man die ergebnisse besser aus tabelle wie netzwerk lesen kann









